<?php
namespace LTItem\SpecialItems\Armor;

use LTItem\SpecialItems\Armor;
use LTItem\Mana\Mana;
use pocketmine\entity\Creature;
use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\inventory\BaseInventory;
use pocketmine\level\particle\DustParticle;
use pocketmine\level\particle\GenericParticle;
use pocketmine\level\particle\Particle;
use pocketmine\level\particle\PortalParticle;
use pocketmine\level\Position;
use pocketmine\level\sound\AnvilFallSound;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\NamedTag;
use pocketmine\nbt\tag\StringTag;
use pocketmine\Player;

class ManaArmor extends Armor implements Mana
{
    const MAX_MANA = 10000;
    private int $Mana;
    private int $lastDamage = 0;
    public function __construct(array $conf, int $count, \pocketmine\nbt\tag\CompoundTag $nbt, $init = true)
    {
        parent::__construct($conf, $count, $nbt, $init);

        $nbt = $this->getNamedTag();
        if(!isset($nbt['armor'][15])){
            $nbt['armor'][15]=new StringTag('',$nbt['armor'][15]??0);//15 对于 ManaArmor来说 15就是Mana
            $this->setNamedTag($nbt);
        }
        $this->Mana = $nbt['armor'][15];
        $this->updateName();
    }

    /**
     * 更新名字
     */
    public function updateName(){
        $this->setCustomName($this->getLTName().PHP_EOL.'§eMana:'.$this->getMana(), true);
    }

    /**
     * @return string 获取这个物品的绑定
     */
    public function getOwner(): string
    {
        return $this->getBinding();
    }

    /**
     * @return int 最大Mana
     */
    public function getMaxMana(): int
    {
        return self::MAX_MANA;
    }

    /**
     * @return int 剩余Mana
     */
    public function getMana(): int
    {
        return $this->Mana;
    }

    /**
     * 保存Mana
     */
    public function saveMana(){
        $tag = $this->getNamedTag();
        $tag['armor'][15] = new StringTag('', $this->Mana);
        $this->setNamedTag($tag);
    }

    /**
     * @param int $mana
     * @return mixed|void
     */
    public function addMana(int $mana)
    {
        $this->Mana += $mana;
        if ($this->Mana>$this->getMaxMana()){
            $this->Mana = $this->getMaxMana();
        }
        $this->saveMana();
    }
    public function setMana(int $mane){
        $this->Mana = $mane;
        if ($this->Mana>$this->getMaxMana()){
            $this->Mana = $this->getMaxMana();
        }
        $this->saveMana();
    }
    /**
     * @param int $mana
     * @return bool
     */
    public function consumptionMana(int $mana): bool
    {
        if ($this->Mana < $mana)return false;
        $this->Mana -= $mana;
        $this->saveMana();
        return true;
    }

    public function onTick(Player $player, int $index, BaseInventory $inventory): bool
    {
        if ($player->getServer()->getTick() - $this->lastDamage > 10){
            if (!$this->canUse($player)){
                $this->lastDamage = $player->getServer()->getTick();
                $player->attack($player->getMaxHealth() * 0.1, new EntityDamageEvent($player, EntityDamageEvent::CAUSE_PUNISHMENT, $player->getMaxHealth() * 0.1, true));
            }
            if ($index < 36)return true;
            if ($this->getMana() < self::MAX_MANA){
                $mana = min(self::MAX_MANA - $this->getMana(), 100);
                if ($player->getBuff()->consumptionMana($mana)){
                    $this->addMana($mana);
                    $inventory->setItem($index, $this);
                }
            }
        }
        return true;
    }

    public function canPutMana(): bool
    {
        return false;
    }
    public function canUse(\pocketmine\Player $player, $playerCheck = true):bool
    {
        return parent::canUse($player, $playerCheck); // TODO: Change the autogenerated stub
    }
    public static function shield(Position $position, $damager = null){
        self::spawnParticle($position, $damager);
        $position->getLevel()->addSound(new AnvilFallSound($position));
    }
    public static function spawnParticle(Position $position, $damager = null){
        $level = $position->getLevel();
        $h = 2.8 / 45;
        $y = $position->getY() - 0.3;
        $v3s = [];
        for ($j = 2; $j < 43; $j++){
            $d = 22 - abs($j - 22);
            $c = abs(1.25 * sin($d * 3.14 / 45));
            $g = 45 / max(1, $d);
            for($i = 1; $i <= $d ; $i++){
                $a=$position->getX() + $c * cos($i * $g * 3.14 / 22.5);
                $b=$position->getZ() + $c * sin($i * $g * 3.14 / 22.5);
                $v3s[] = new Vector3($a,$y + $h * $j,$b);
            }
        }
        if ($damager != null){
            /** @var Creature $damager */
            $damager = $damager->add(0, $damager->getEyeHeight(), 0);
            $minV3 = [PHP_INT_MAX, null];
            /** @var Vector3 $v3 */
            foreach ($v3s as $v3){
                $d = $v3->distance($damager);
                if ($d < $minV3[0])$minV3 = [$d, $v3];
            }
            foreach ($v3s as $v3){
                if ($v3->distance($minV3[1]) < 0.8)
                    $level->addParticle(new GenericParticle($v3,Particle::TYPE_REDSTONE));
            }
        }else{
            foreach ($v3s as $v3){
                $level->addParticle(new GenericParticle($v3,Particle::TYPE_REDSTONE));
            }
        }
    }
}